%!TEX root = nextndnvideo-tr.tex
\section{background} % (fold)
\label{sec:background}
\subsection{Consumer / Producer API}
Consumer-Producer API~\cite{api-tr} provides a generic programming interface to NDN communication protocols and architectural modules. A consumer context associates an NDN name prefix with various data fetching, transmission, and content verification parameters, and integrates processing of Interest and Data packets on the consumer side. A producer context associates an NDN name prefix with various packet framing, caching, content-based security, and namespace registration parameters, and integrates processing of Interest and Data packets on the producer side.

In both video project, the video publisher behaves as the producer and generates video and audio frames separately. The users behave as the consumer sending Interests asking for video to play back. The Consumer / Producer API simplified the work of data production and consumption in both side. For example, we find that some video frames are too large to be encapsulated by a single Data packet, and the producer side of the application would have to perform content segmentation in order to split the content into multiple Data packets. The Producer API will do the segmentation inside one video frame automatically. At the same time, a video frame cannot be retrieved by a single Interest packet, and the Consumer API will pipeline Interest packets and solve other tasks related to the retrieval of the application frame as long as we set up the right Data Retrieval Protocol\textit{(SDR/UDR/RDR)}. In the case of MPEG-DASH, all these low-level details are handled by the HTTP / TCP protocol machinery. We will talk about the implementation details in Section~\ref{sec:implementation}.
\subsection{Gstreamer}

We use Gstreamer~\cite{gstreamer} to handle the media processing part. 

For NDNLive, the raw video pictures captured by camera would be transferred to \textit{Encoder\_v} component and will be encoded into \textit{H264} format. Then the encoded video is transmitted into \textit{Parser\_v} to get parsed into frames (\textit{B, P or I frame}). For audio, the microphone will capture the audio then push the raw audio into \textit{Encoder\_a}. The encoder component will encode the raw audio into \textit{AAC} format. The encoded audio stream will be transferred to \textit{Parser\_a} to get parsed then passed to Consumer / Producer API to be produced.

The main difference of NDNTube from NDNLive is the video source, which is the video file. Gstreamer should firstly read video file then pass it to the \textit{Demuxer} component to separate video and audio stream. Because the video file is already encoded, so there is no \textit{Encoder} component here. The separate encoded video or audio is pushed into the \textit{Parser} to generate frames.

Because we need to extract the frames from the video source, so now we only support \textit{H264} video encoded format and \textit{AAC} audio encoded format for NDNLive and \textit{MP4} file format for NDNTube. 

\subsection{Repo-ng}
For NDNLive, the captured video and audio is always streaming and the producer just keeps producing the latest frames and doesn't care about the data it produced several minutes ago. The consumer will also only request for the current frame which is just produced. So as long as the producer is attached to the NDN network and then can respond to the Interests. The consumer can get the data back and play them back immediately.

But for NDNTube, once the video file is uploaded to the producer part, it is permanent. And the same video file could be requested several times. So the video file should be produced just once then be stored somewhere else and exposed to the NDN Network and waiting for retrieved. Otherwise, every time different users request for the same piece of data will cause the regeneration and production in the producer side if the cache doesn't contain such piece of data.

Repo-ng~\cite{repo-ng} is introduced to provide the permanent storage for the video data. Repo-ng (repo-new generation) is an implementation of NDN persistent in-network storage conforming to Repo protocol~\cite{Repo-Protocol}. In the last report, we won't distinguish Repo-ng and Repo. Repo insertion is natively supported by the Consumer / Producer API. You can just set the \textit{LOCAL\_REPO} option as TRUE, all the data producer generated will be inserted into local repo, or set the option \textit{REMOTE\_REPO} with appropriate \textit{Repo\_Prefix}, the data will be inserted into the remote repo which matches the prefix.
% section section_name (end)